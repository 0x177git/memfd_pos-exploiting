# entendendo os conceito de shellcode

seria desnecessario explicar de forma ampla e detalhista esta parte, existe mto conteudo disponivel e ateh livros pra detalhar esta arte, mas basicamente, o que pretendemos aqui eh escrever nosso code em memoria e executar

Porem a questao eh mais complexa que apenas isso, por exemplo se formos ler uma das primeiras referencias sobre shellcoding (_associada a buffer overflow e que ateh hj existe um vinculo quase simbolico_), podemos encontra-la no [issue 46 do phrack](http://phrack.org/issues/49/14.html)

devo resaltar que este post do phrack eh quase poetico,  mas vamos ao cerne da questao

aqui temos uma clara e interessante explicaçao de como funciona o _buffer overflow_(antes do ASLR e antes de que o segmento de  `stack` deixasse de ter permissao de execuçao por convençao) mas basicamente a explicaçao sobre a  `stack` funciona ateh hj com vulnerabilidades relacionadas a o exploiting de heap e stack

ali descobrimos se antes nao soubessemos, algo bem interessante, o funcionamento e a mecanica da stack.
Basicamente a funçao da e `stack` eh armazenar e referenciar as variaveis locais das funçoes, os parametros e argumentos de retorno, porem, tmb existem os __stack frames__, que basicamente empilham a funçao quando ela eh chamada e desempilha (prologo) quando esta retorna ao _main_ ou funçao principal 
> se vc nunca tiver tido com assmebly vai ficar um pouco confuso, mas pra isso recomendo dms o livro do [mente binaria](https://mentebinaria.gitbook.io/assembly/a-base/registradores-de-proposito-geral)
> recomendo ler o livro pra ter uma visao ampla do que vamos analisar, se vc nao tiver costume com assembly, nem noçoes de sistema operacional vai levar um poquinho de tempo. mas eh normal, o livro foi feito com esse proposito, como um guia de estudos, aquilo que nao entender, vai procurando, tem mto conteudo bom, o livro serve como um otimo guia e como um sistema de apresentaçao bem legal

----
mas bem, chegando aqui imagino que jah haja uma noçao basica de registradores e a difereneça entre registradores de proposito geral

basicamente, os registradores de `stack` vao efetuar as operaçoes pra posicionamento de memoria no segmento de `stack` e ira procurar as variaveis locais e apontar pra o proximo frame, ou seja a funçao que sera chamada

um detalhes interessante eh saber que existe um mecanismo bem legal chamado prologo, que basicamente desempilha a base do `stack` e aponta pra o topo, que geralmente acontece qndo entramos em uma nova funçao

aqui temos um pequeno code que vai mostrar um i no terminal

```
#include <stdio.h>

int main()
{
puts("i");
}

```

bem, vamos compilar e executar, no meu ambiente to usando gdb com [gef](https://hugsy.github.io/gef/) uma otima tool que em conjunto que vai nos ajudar a entender o que ta acontecendo

![image](https://github.com/0x177git/memfd_pos-exploiting/assets/138733317/27e30138-3ee5-4cc4-a880-e9267752523d)


entao, basicamente eu apenas adicionei um breakpoint no main() do binario, e podemos ver como antes do nosso breakpoint temos duas instruçoes `push rbp / mov rpb, rsp` 
estas sao o prologo do qual falei antes, que basicamente tira o `rbp` e posiciona o `rsp` como novo `rbp` no seu lugar (basicamente pq antes de chamar a funçao o `rsp` apontava pra `main`, jah que esta era a proxima funçao empilhada, ou seja, o topo da stack), ou seja estamos nós posicionando na base da pilha (`rbp`) porem com o valor que antes tava em `rsp`, assim a nossa main se torna a base do `stack` 

o endereço pra o qual gdb colocou o breakpoint, carrega o conteudo do `rip+0xec0` dentro da `rax`, como podemos ver o rip naquela posiçao aponta pra o endereço `0x555555556004`
ao analisar o conteudo dele (`p *0x555555556004`) vemos que seu conteudo eh o equivalente a "i" em hexadecimal
as proximas instruçoes movem a `rax` pra dentro do `rdi` e fazem a call a `puts` com o conteudo de `rdi` como argumento

ateh aqui soh tivemos na `stack` o prologo e o `ret` dps da call, que basicamente desempilha o `rbp`

e se no nosso code escrevemos uma variavel do tipo `int` contendo 0??, soh isso, sem modificar mais nada

vamos ver o que acontecer com nossa stack??

![image](https://github.com/0x177git/memfd_pos-exploiting/assets/138733317/e459c793-4a45-4417-b39c-1d2ef76c2b7e)

vemos duas novas instruçoes, e as duas ocorrem na stack, vamos entender??

a primeira (`sub rsp, 0x10`), basicamente aloca espaço no topo da pilha, subtraindo 16 byte (lembrando que a `stack` cresce pra baixo)

e a segunda `mov PTR DWORD [rbp-0x4], 0x0` , move 0 pra um espaço de 4 bytes na stack, no espaço que foi alocado, ali vemos que ele reserva 4 bytes, basicamente pq qndo declaramos a variavel 0, inicializamos como um `int` que ocupa 4 bytes, se formos no nosso code e modificarmos o tipo da nossa variavel pra `char`, estariamos alocando 1 byte, ou seja `mov PTR WORD [rbp-0x1], 0x0` 
> soh pra qestao de esclarecimento, tem uma diferença entre a primeira e a segunda operaçao, a primeira, de fato substrai(aloca) 16 espaços na `stack` (0x10) jah a segunda, ta movendo elemento pra posiçao referenciada, ou seja `rbp-0x4`, por isso eh usado o `rbp`, pra posicionar a partir da base

uma imagem de como ficaria nossa `stack` 

com tipo `int`
```
  _ _ _ _ _ _ _
|    _ _ _ _    | RSP 
|    _ _ _ _    | 
|    _ _ _ _    | 
|    _ _ _ _    | 
|    _ _ _ _    | 
|    _ _ _ _    |  
|    _ _ _ _    | 
|    _ _ _ _    | 
|    _ _ _ _    |
|    _ _ _ _    |  
|    _ _ _ _    | 
|    _ _ _ _    | 
|    _ _ _ _    | 
|               |
|        0      |
|               |
 _ _ _ _ _ _ _ _  RBP
```

temos 16 espaços alocados pelo `rsp` pra variaveis locais e 4 que esta sendo ocupado pelo 0 desde o `rbp`
```
  _ _ _ _ _ _ _
|    _ _ _ _    | RSP 
|    _ _ _ _    | 
|    _ _ _ _    | 
|    _ _ _ _    | 
|    _ _ _ _    | 
|    _ _ _ _    |  
|    _ _ _ _    | 
|    _ _ _ _    | 
|    _ _ _ _    |
|    _ _ _ _    |  
|    _ _ _ _    | 
|    _ _ _ _    | 
|    _ _ _ _    |
|    _ _ _ _    |
|    _ _ _ _    |
|    _ _ _ _    |
|        0      |
 _ _ _ _ _ _ _ _  RBP
```

temos 16 espaços alocados pelo `rsp` pra variaveis locais e 1 de fato usada pelo `rbp`pra 0


* pra quem ta se perguntando pq o `rsp` alocou 16 espaços, estes sao equivalentes a uma _WORD_, se por exemplos, na nossa variavel criarmos um vetor de 17 bytes (`char i[17] = 0`), qndo formos analisar veremos que o nosso `rsp` alocou uma DWORD (DOUBLE-WORD) ou seja, 32 bytes, jah que este eh o espaço mais proximo que poderia ser alocado pra nossa variavel de 17 bytes, pra fim de esclarecimento temos __BYTE,WORD, DWORD, QWORD__ entre outros
* Por exemplo eh se reescrevermos o conteudo do `i`, estaremos na verdade rescrevendo o conteudo na  posiçao da stack
   ou seja supondo que a posiçao de `i` na `stack` seja `rbp-0x1`, qndo modificamos o valor de `i` estamos apenas reescrevendo o conteudo na `stack` ou seja na posiçao `rbp-0x1`

      > isso funciona pra variaveis locais, pra variaveis globais dependendo do tipo serao armazenadas dentro do segmentos `bss` ou `data` (se tiverem sido inicializada) e pra dinamicas estarao no `heap`
  
recomendo brincar com isso e fazer testes a fim de entender melhor estes mecanismo

# brincando com a `stack` pra testar shellcode

bem, tendo entendido estes conceito vamos pra uma parte bem relevante, ateh agr soh falamos sobre a `stack` e eh que a `stack` vai ser o cenario dos nossos testes e prototipos

por convençao, o segmento de  `stack` nao tem permissos de execuçao, pra isso iremos precissar atribuir essa permissao (flag) ao segmento de `stack`, pra isso iremos setar as flags -z exestack (considerando que compilemos usando gcc) 

mas antes vamos criar nosso prototipo pra o cenario de teste

```

int main() {
  char code[] = "shellcode" /*aqui iremos escrever nosso shelcode*/
  int (*func)() = (int (*)()) code;   /* agr iremos definir um ponteiro de funçao do tipo int que aponta pra nossa variavel code[] e sabemos que ta na stack pq inicializamos ela localmente */
  (int)(*func)();  /* e agr vamos chamar nosso ponteiro */
```
> aqui estamos definindo nossa variavel "shellcode" que contem um buffer de bytes

> criamos um ponteiro pra funçao e o prototipo da funçao vai ser um ponteiro pra nosso conteudo dentro do code

> e dps invocamos nossa funçao

> - em alguns exemplos que vao ter por ai em databases de exploits e vlogs vamos ver algo parecido, porem a variavel que contem um shellcode eh declarada fora do main, como uma variavel global; porem em versoes e patch mais recentes do kernel e do gcc, qndo definimos a flag exestack, vamos dar o permisso de execuçao apenas ao segmento de stack, ou seja, nossa variavel precisa ser local, pra que seja psoicionada dentro das paginas (segmentos) de stack, tem um post no medium do [angelystor](https://medium.com/csg-govtech/why-doesnt-my-shellcode-work-anymore-136ce179643f) mostrando como tdo isso funciona



