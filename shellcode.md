# entendendo os conceito de shellcode

seria desnecessario explicar de forma ampla e detalhista esta parte, existe mto conteudo disponivel e ateh livros pra detalhar esta arte, mas basicamente, o que pretendemos aqui eh escrever nosso code em memoria e executar

Porem a questao eh mais complexa que apenas isso, por exemplo se formos ler uma das primeiras referencias sobre shellcoding (associada a buffer overflow e que ateh hj existe um vinculo quase simbolico), podemos encontra-la no [issue 46 do phrack](http://phrack.org/issues/49/14.html)
devo resaltar que este post do phrack eh quase poetico,  mas vamos ao cerne da questao
aqui temos uma clara e interessante explicaçao de como funciona o buffer overflow (antes do ASLR e antes de que o segmento de stack deixasse de ter permissao de execuçao por convençao) mas basicamente a explicaçao sobre a stack funciona ateh hj com vulnerabilidades relacionadas a o exploiting de heap e stack
ali descobrimos se antes nao soubessemos, algo bem interessante, o funcionamento e a mecanica da stack
basicamente a funçao da estack eh armazenar e referenciar as variaveis locais das funçoes e os parametros e argumentos de retorno, porem, tmb existem os stack frames, que basicamente empilham a funçao quando ela eh chamada e desempilha quando esta retorna ao main ou funçao principal 
se vc nuncac tiver tido com assmebly vai ficar um pouco confuso, mas pra isso recomendo dms o livro do [mente binaria](https://mentebinaria.gitbook.io/assembly/a-base/registradores-de-proposito-geral)
recomendo ler o livro pra ter uma visao ampla do que vamos analisar, se vc nao tiver costume com assembly, nem noçoes de sistema operacional vai levar um poquinho de tempo, mas eh normal, o livro foi feito com esse proposito, como um guia de estudos, o que nao entender, vai procurando, tem mto conteudo bom, o livro serve como um otimo guia e como um sistema de apresentaçao bem legal

----
mas bem, chegando aqui imagino que jah haja uma noçao basica de registradores e a diferneça entre registradores de proposito geral
mas basicamente, os registradores de stack vao efetuar as operaçoes pra posicionamento de memoria no segmento de stack e ira procurar as variaveis locais e apontar pra o proximo frame, ou seja a funçao que sera chamada
um detalhes interessante eh saber que existe um mecanismo bem legal chamado prologo, que basicamente desempilha a base do stack e aponta pra o topo, que geralmente acontece qndo entramos em uma nova funçao

aqui temos um pequeno code que vai mostrar um i no terminal

```
#include <stdio.h>

int main()
{
puts("i");
}

```

bem, vamos compilar e executar, no meu ambiente to usando gdb com [gef](https://hugsy.github.io/gef/) uma otima tool que em conjunto que vai nos ajudar a entender o que ta acontecendo

![image](https://github.com/0x177git/memfd_pos-exploiting/assets/138733317/27e30138-3ee5-4cc4-a880-e9267752523d)


entao, basicamente eu apenas adicionei um breakpoint no main() do binario, e podemos ver como antes do nosso breakpoint temos duas instruçoes `push rbp / mov rpb, rsp` 
estas sao o prologo do qual falei antes, que basicamente tira o `rbp` e posiciona o `rsp` como novo `rbp` no seu lugar (basicamente pq antes de chamar a funçao o `rsp` apontava pra `main`, jah que esta era a proxima funçao empilhada, ou seja, o topo da stack), ou seja estamos nós posicionando na base da pilha (`rbp`) porem com o valor que antes tava em `rsp`, assim a nossa main se torna a base do stack 

o endereço pra o qual gdb colocou o breakpoint, carrega o conteudo do `rip+0xec0` dentro da `rax`, como podemos ver o rip naquela posiçao aponta pra o endereço `0x555555556004`
ao analisar o conteudo dele (`p *0x555555556004`) vemos que seu conteudo eh o equivalente a "i" em hexadecimal
as proximas instruçoes movem a `rax` pra dentro do `rdi` e fazem a call a `puts` com o conteudo de `rdi` como argumento

ateh aqui soh tivemos na stack o prologo e o `ret` dps da call, que basicamente desempilha o `rbp`

e se no nosso code escrevemos uma variavel do tipo `int` contendo 0??, soh isso, sem modificar mais nada

vamos ver o que acontecer com nossa stack??

![image](https://github.com/0x177git/memfd_pos-exploiting/assets/138733317/e459c793-4a45-4417-b39c-1d2ef76c2b7e)

vemos duas novas instruçoes, e as duas ocorrem na stack, vamos entender??

a primeira (`sub rsp, 0x10`), basicamente aloca espaço no topo da pilha, subtraindo 16 bit (lembrando que a stack cresce pra baixo)

e a segunda `mov PTR DWORD [rbp-0x4], 0x0` , move 0 pra um espaço de 4 bits na stack, no espaço que foi alocado, ali vemos que ele reserva 4 bits, basicamente pq qndo declaramos a variavel 0, inicializamos como um `int` que ocupa 4 bits, se formos no nosso code e modificarmos o tipo da nossa variavel pra `char`, estariamos alocando 1 bit, ou seja `mov PTR WORD [rbp-0x1], 0x0` 
> soh pra qestao de esclarecimento, tem uma diferença entre a primeira e a segunda operaçao, a primeira, de fato substrai(aloca) 16 espaços na stack (0x10) jah a segunda, ta movendo elemento pra posiçao referenciada, ou seja `rbp-0x4`, por isso eh usado o `rbp`, pra posicionar a partir da base

uma imagem de como ficaria nossa stack 

com tipo `int`
  _ _ _ _ _ _ _
|    _ _ _ _    | RSP 
|    _ _ _ _    | 
|    _ _ _ _    | 
|    _ _ _ _    | 
|    _ _ _ _    | 
|    _ _ _ _    |  
|    _ _ _ _    | 
|    _ _ _ _    | 
|    _ _ _ _    |
|    _ _ _ _    |  
|    _ _ _ _    | 
|    _ _ _ _    | 
|    _ _ _ _    | 
|               |
|        0      |
|               |
 _ _ _ _ _ _ _ _  RBP

temos 16 espaços alocados pelo `rsp` pra variaveis locais e 4 que esta sendo ocupado pelo 0 desde o `rbp`

  _ _ _ _ _ _ _
|    _ _ _ _    | RSP 
|    _ _ _ _    | 
|    _ _ _ _    | 
|    _ _ _ _    | 
|    _ _ _ _    | 
|    _ _ _ _    |  
|    _ _ _ _    | 
|    _ _ _ _    | 
|    _ _ _ _    |
|    _ _ _ _    |  
|    _ _ _ _    | 
|    _ _ _ _    | 
|    _ _ _ _    |
|    _ _ _ _    |
|    _ _ _ _    |
|    _ _ _ _    |
|        0      |
 _ _ _ _ _ _ _ _  RBP

temos 16 espaços alocados pelo `rsp` pra variaveis locais e 1 de fato usada pelo `rbp`pra 0

* pra quem ta se perguntando pq o rsp alocou 16 espaços 
