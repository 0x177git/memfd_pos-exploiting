# memfd_pos-exploiting
aqui irei falar sobre esta syscall e irei aproveitar pra passar entre outros conceitos do pos-exploiting e de assembly, basicamente podemos alocar um espaço de memoria anonimo com as propiedades de um `descritor` (escritura, leitura, execuçao e mapeamento) 

## [memfd_notes](https://github.com/0x177git/memfd_pos-exploiting/blob/main/memfd_notes.md) 
aqui explicou como funciona esta syscall e suas propiedades, tmb suas semelhanças com `open()`e `fcntl()` (basicamente poder definir atributos como MFD-CLOEXEC e implementar o conceito de `sealing` pra compartilhamento de memoria entre processos ou threads) 
e desenvolvo um pequeno projeto feito em `c` pra carregar um elf em memoria e executar apartir do descritor retornado por `memfd()`

>- prototype
>
![memfd() man](https://github.com/0x177git/memfd_pos-exploiting/blob/main/man_memfd().jpg?raw=true)

----
## [conceitos basicos pra testes e desenvolvimento de shellcode](https://github.com/0x177git/memfd_pos-exploiting/blob/main/basic_concepts_of_stack.md)
aqui me tomei um tempinho pra explicar a abstraçao e mecanica da `stack`, achei interessante isso pra ter uma base legal pra os menos experientes, falo sobre os diferentes tipos de espaços em memoria e foco explicitamente na `stack`

analiso com `gdb` como funciona na pratica este segmento de memoria e a dinamica de alocaçao e alinhamento (_prologo e ret_) tmb explico sobre como podemos usar a `stack` pra executar code diretamente, nao chego a detalhar esta parte na pratica, mas deixo o mais claro possivel o que estamos fazendo antes de entrar de fato no desenvolvimento em assembly e as propiedades do desenvolvimento de shellcode (*evitar 0x0, nop sleep, gerenciamento do tamanho de registradores e jump*) 

----
## [Principos e Estrategias de Desenvolvimento](https://github.com/0x177git/memfd_pos-exploiting/blob/main/principios%26estrategias.md)
aqui comecei a trabalhar com os principos do shellcoding, passando pelos elementos que compõem o `set instruction` (opcodes), os tamanho e  a manipulaçao de registradores em x64 (evitando NULL e diminuindo o tamanho do shellcode accessando apenas o index do registradores por tamanho [BYTE, WORD, DWORD, QWORD]), implementação de desvios de execuçao (0x90) pra burlar ASLR e o layout de syscall do linux

acabamos desenvolvendo um shellcode que muda o nucleo do processo chamando `execve()` com /bin/sh como argumento e dps implementamos uma tecnica de execuçao em stack usando `c` pra testar nosso shellcode
