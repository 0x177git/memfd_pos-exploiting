# desenvolvendo um shellcode com base em memfd()

bem, recentemente estive studando esta _syscall_ dps de ver um vlog comentando sobre uma possibilidade de executar segmentos de _elf_ sem usar `/tmpfs`. Pra quem nao conhece, basicamente permite criar um _descritor_ em um espaço de memoria, ou seja, aloca um espaço de memoria com flag do `open()` e `fcntl()`(_no contexto da pos-exploraçao eh incrivel, jah que podemos carregar sockets, binarios ou qlqr tipo de descritor sem nem sequer tocar o disco_), pra entender melhor, recomendo bastante ter uma noçao de c e syscall, porem vou tentar ser o mais claro possivel enquanto isso nao afete a profundidade ou desvie o escopo do estudo

## [memfd_create()](https://man7.org/linux/man-pages/man2/memfd_create.2.html)
antes de entrar em detalhes sobre o desenvolvimento de um shellcode ou assembly, primeiramente precissamos entender como funciona esta syscall

![man memfd()](https://github.com/0x177git/memfd_pos-exploiting/assets/138733317/f262bf4e-cfa2-4726-a2e7-311680e9840c)

Ao ler o _man_ desta syscall, podemos ver que ela vai receber dois argumentos, primeiramente um argumento do tipo `char` e um do tipo `flag` 

o primeiro nao eh nada alem do que o nome que sera dado ao descritor no link simbolico dentro de `/proc` (__pseudo-filesystem virtual__) (*lembrando que este fica apenas como um link simbolico, jah que esta partiçao apenas existe pra representar o kernel e nao eh carregada no disco, apenas na memoria RAM, RECOMENDO MTO LER MAIS SOBRE `/proc` E `/sys` pra entender pq estas existem e o importante papel delas dentro do kernel, jah que literalmente podemos analisar e interagir em tempo real com o kernel durante execuçao*) e o segundo eh o tipo de descritor; o segundo parametro compartilha de forma bem semelhante as caracteristicas e propriedades do `open()`

O que nao eh estranho, jah que compartilham o mecanismo de criar um descritor, que eh basciamente o que a syscall `open()` faz e por ser um descritor, entendemos tmb que possui as propriedades de um file criado com `open()`, que eh o de leitura, escritura, execuçao e mapeamento de memoria. a diferença crucial entre estes dois eh que o descritor criado com `memfd()` vive e morre na memoria RAM, ou seja, sua principal caracteristica eh a do seu espaço, que um espaço volatil e apenas eh mantido no espaço de memoria enquanto este for referido, ao ser fechado, o descritor desaparece 
* uma questao relevante sobre as flags que devo mencionar eh a seguinte, como esta syscall foi introduzida com o objetivo de ser um meio de memory-sharing, existe um conjunto de flag denominadas `sealing` que dao propriedades extra ao descritor, este tipo de operaçao em descritor (como eh descrito pelo [_man_](https://man7.org/linux/man-pages/man2/memfd_create.2.html)) herdada do `fcntl(` faz com que o arquivo possa ser apenas lido, ou `selado` com permissoes especificas do processo, por exemplo, digamos que eu desejo enviar um arquivo (file descritor) do tipo `memfd()` a outro processo pra compartilhar informaçao, eu posso selar esse descritor como apenas leitura, pra invocar este tipo de flag usa `ALLOW_SEALING`, nao vou falar mto mais sobre isso no restante do post, pq pra o que iremos precissar nao eh necessario implementar esta caracteristica, mas fica a explicaçao caso caiba em algum contexto da pos-exploraçao
* aqui ha mais detalhes [File sealing & memfd()](https://lwn.net/Articles/591108/)

uma das flags que mais iremos usar sera `FD_CLOEXEC`, herdada do `open()`, que basicamente fecha o descritor apos execuçao, pra ler mais recomendo ver o [_man_](https://man7.org/linux/man-pages/man2/open.2.html) do `open()`
uma pergunta que pode surgir aos mais experientes eh, qual eh a diferença do `memfd()` pra o `shm_open()` e eh que basicamente, `smh_open()` aloca um espaço de memoria que sera compartilhado entre os processos, jah o `memfd()` nao apenas aloca esse espaço como `smh`, mas tmb dah a este espaços os atributos de um descritor

aqui um code soh pra esclarecer

```c
int main()
{
char* environ[]={"",(char*)0};  /* zeramos as variaveis env e argv necessarias pra a syscall fexecve, eu fiz assim, mas em alguns casos vc pode simplesmente declarar NULL ou inicializar o char com 0, jah que como sabemos um char eh um vetor que termina em 0, basicamente um vetor char hello[] = "helloSHELL" eh equivalente a char hello [11]; hello = {"h","e","l","l","o"..."L",0} */
  char* argv[]={"",(char*)0};
  char name[] = ""; /* aqui vamos dfinir o nome do link simbolico do memfd(), que ficara vazio, vc pode usar por exemplo um nome imitando um daemon ou modulo do sistema, qndo vc inicializar o processo com execve(), ele ira aparecer na lista de processos com o nome que vc definiu ao descritor, neste caso ira aparecer um nome vazio */
   int fd = memfd_create(name, FD_CLOEXEC); /* como jah expliquei aqui chamamos o memfd_create() com o nome e a flag FD_CLOEXEC || cabe ressaltar que ele foi aramazenado como int jah que segundo o prototipo da syscall ela ira retornar um inteiro apontado pra o descritor criado (/proc/$PROCCESS_PID/fd/$descritor
 ptr = fopen("exit", "rb") /* aqui eu vou escrever no meu descritor um elf feito em assembly que ira sair do processo retornando 0, nao eh nada de especial, apenas tentei criar um elf o mais pequeno possivel */
while (!feof(ptr)) /*aqui eu uso a funçao fread pra ler o conteudo do elf "exit" por blocos de 16 bytes e armazeno em uma variavel buff, que depois com a sycall write() eu esvcrevo dentro do descritor criado com memfd()*/
 {
  fread(buff, sizeof(char), 16, ptr);
  write(fd, buff, 16);
  }
  fclose(ptr); 
  fexecve(fd, argv , environ); /* aqui invoco a syscall fexecve() que ira executar um processo apartir de um file descritor, ou seja nosso descritor criado com memfd()*/
  return(0);
  } 
```
nesse caso, usei um _elf_ que chamei de "exit" e escrevi ele dentro do descritor criado com `memfd_create()`, dps fiz uma syscall `fexecve()`(_igual a execve porem que pode ser invocada atraves de um descritor local em vez de um path_) e basicamente, se analisamos este pequeno code em execuçao, iremos ver um processo sem nome que retornou 0, lembrando que isso aqui pode ser feito com _fork()_

> pra expandir o entendimento de pos-exploraçao em memoria recomendo dms o post do [magisterqis](https://magisterquis.github.io/2018/03/31/in-memory-only-elf-execution.html) onde ele explica varias das coisas que foram ditas aqui, porem em perl, o que eh mto legal, jah que como ele mostra no seu video, pode ser carregado desde qlqr lugar que deh acceso a um interpretador perl, ha algumas leves diferenças que nao afetam a parte conceitual 

